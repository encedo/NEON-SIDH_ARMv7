/*
	NEON-SIDH: Efficient Implementation of Supersingular Isogeny Diffie-Hellman
		Key Exchange Protocol on ARM
		
	Authors: Brian Koziel, Amir Jalali, Reza Azarderakhsh, David Jao, and
		Mehran Mozaffari-Kermani
		
	Link to published paper: To be posted 
		
	Previous versions by Luca de Feo and Dieter Fishbein
	
	util.h: Utility functions used in the SIDH tests
	
	Copyright (c) Brian Koziel 2016

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "util.h"

//returns a random integer from 0 to m (inclusive)
void rand_range(mpz_t *num, mpz_t m){
  unsigned long int bytes;
  mpz_t *tmp1, *tmp2;
  tmp1 = malloc(sizeof(mpz_t));
  tmp2 = malloc(sizeof(mpz_t));
  mpz_init(tmp1);
  mpz_init(tmp2);
  bytes = ceil( mpz_sizeinbase(m, 2)/8.0 ) + 20;
  unsigned char buf[bytes];
  RAND_bytes(buf, bytes);
    
  unsigned char buf1[bytes];
  char* buf2 = buf1;

  int k=0;
  for (k; k < bytes; k++)
    buf2 += sprintf(buf2, "%02X", buf[k]);
    
  sprintf(buf2,"\n");
  *(buf2 + 1) = '\0';
  mpz_set_str(tmp1, buf1, 16);
  mpz_add_ui(tmp2, m, 1);
    
  mpz_mod(num, tmp1, tmp2);
  
  mpz_clear(tmp1); mpz_clear(tmp2);
  free(tmp1);free(tmp2);
}

void rand_subgroup(mpz_t *m, mpz_t *n, char * l, char * e){
  mpz_t *num, *_l, *_e, *tmp1, *le, *le1, *l1;
  num = malloc(sizeof(mpz_t));
  _l = malloc(sizeof(mpz_t));
  _e = malloc(sizeof(mpz_t));
  tmp1 = malloc(sizeof(mpz_t));
  le = malloc(sizeof(mpz_t));
  le1 = malloc(sizeof(mpz_t));
  l1 = malloc(sizeof(mpz_t)); 
  long int e_int = 0;
  e_int = atoi(e);
  mpz_init(le);
  mpz_init(le1);
  mpz_init(l1);
  mpz_init(tmp1);
  mpz_init(num);
    
  mpz_init_set_str(_l, l, 10);
  mpz_init_set_str(_e, e, 10);
  mpz_add_ui(l1, _l, 1);
  rand_range(num, *l1);      
  if ( mpz_cmp_ui(*num,1)==0 ){
    mpz_set_ui(m,1);
	mpz_pow_ui(le, _l, e_int);
    rand_range(n, *le);
	mpz_setbit(n,mpz_sizeinbase(le, 2));
  }else{
    mpz_pow_ui(le1, _l, e_int);
    rand_range(m, *le1);
    mpz_setbit(m,mpz_sizeinbase(le1, 2));
    mpz_set_ui(n,1);
  }
  mpz_clear(num); mpz_clear(_l); mpz_clear(_e); mpz_clear(tmp1); mpz_clear(le); mpz_clear(le1); mpz_clear(l1);
  free(num);free(_l);free(_e);free(tmp1);free(le);free(le1);free(l1);
}

//reads public parameters for use with ss_isogeny_exchange_dfc in from file. Note that this file must match the format and naming conventions
//of the one generated by ss_isogeny_gen_file().
void params_from_file(char * p, char *eA, char *eB, char *lA, char *lB, char* fMult, int *strA, int *lenA, int *strB, int *lenB, MP *PA, MP *QA, MP *PB, MP *QB, char * file ){
  FILE *fr; 
  fr = fopen (file, "rt");
  MC curve;
  int lineMax = 10000;
  char line[lineMax];

  //taking in p,lA, lB, eA, eB
  fgets(line, lineMax, fr);
  sscanf (line, "%s", p);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", lA);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", lB);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", eA);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", eB);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", fMult);
    
  //taking in the curve
  fp2 A, B, A24;
  fp2_setup(p);
  
  MC_init(&curve);

  char *a;
  char *b;
  a = malloc(sizeof(char)*lineMax);
  b = malloc(sizeof(char)*lineMax);

  fp2_init(&A);
  fp2_init(&B);
  fp2_init(&A24);
  
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&A, a, b);
   
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&B, a, b);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b); 
  fp2_set(&A24, a, b);

  MC_set_curve( &curve, A, B, A24);
  
  //taking in PA
  fp2 x1,y1,z1;  
  fp2_init(&x1);
  fp2_init(&y1);
  fp2_init(&z1);
   
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&x1, a, b);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&y1, a, b);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);  
  fp2_set(&z1, a, b);
    
  MP_set( PA, x1, y1, z1, curve );
    
    //taking in QA
  fp2 x2,y2,z2;
  fp2_init(&x2);
  fp2_init(&y2);
  fp2_init(&z2);
     
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&x2, a, b);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&y2, a, b);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&z2, a, b);
    
  MP_set( QA, x2, y2, z2, curve );
    
  //taking in PB
  fp2 x3,y3,z3;  
  fp2_init(&x3);
  fp2_init(&y3);
  fp2_init(&z3);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b); 
  fp2_set(&x3, a, b);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&y3, a, b);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&z3, a, b);
    
  MP_set( PB, x3, y3, z3, curve );
    
  //taking in QB
  fp2 x4,y4,z4;
  fp2_init(&x4);
  fp2_init(&y4);
  fp2_init(&z4);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&x4, a, b);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&y4, a, b);
    
  fgets(line, lineMax, fr);
  sscanf (line, "%s", a);
  fgets(line, lineMax, fr);
  sscanf (line, "%s", b);
  fp2_set(&z4, a, b);
    
  MP_set( QB, x4, y4, z4, curve );
    
  //taking in strA
  fgets(line, lineMax, fr);
  sscanf (line, "%d", lenA);
    
  int k=0;
  for(; k<*lenA; k++){
    fgets(line, lineMax, fr);
    sscanf (line, "%d", &strA[k]);
  }
    
  //taking in strB
  fgets(line, lineMax, fr);
  sscanf (line, "%d", lenB);
    
  int r=0;
  for(; r<*lenB; r++){
    fgets(line, lineMax, fr);
    sscanf (line, "%d", &strB[r]);
  }
    
  free(a);
  free(b);
}

//Get Median of list of times for program.
double getMedian(double * array,int size){
  //Sort array using insertion sort
  int c,d;
  double t;
  for (c = 1 ; c <= size - 1; c++) {
    d = c;
    while ( d > 0 && array[d] < array[d-1]) {
      t          = array[d];
      array[d]   = array[d-1];
      array[d-1] = t;
      d--;
    }
  }
  //Get middle element from sorted list
  if(size%2 == 1){
    return array[size/2];
  } else{
    return (array[size/2-1]+array[size/2])/2;
  }
}