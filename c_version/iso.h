/*
	NEON-SIDH: Efficient Implementation of Supersingular Isogeny Diffie-Hellman
		Key Exchange Protocol on ARM
		
	Authors: Brian Koziel, Amir Jalali, Reza Azarderakhsh, David Jao, and
		Mehran Mozaffari-Kermani
		
	Link to published paper: To be posted 
		
	Previous versions by Luca de Feo and Dieter Fishbein
	
	iso.h: Isogeny structures and computational methods
	
	Copyright (c) Brian Koziel 2016

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef ISO_H
  #define ISO_H
  
#include "fp.h"
#include "fp2.h"
#include "mont_curve.h"
  
typedef struct point_queue point_queue;  

typedef struct {
  fp2 u, r;
} iso;

typedef fp2 iso2;

typedef struct {
  fp2 p, p2;
} iso3;

typedef struct {
  fp2 Ap2;
} iso4;

/*
  Compute an isomorphism of the montgomery curve
  sending (x,z) to (0,0).
*/
void isom_comp(iso* iso, MC *phiE, const MC E, const KP P);

/* Apply an isomorphism of Montgomery curves */
void isom_eval_kummer(KP *Q, const iso iso, const KP P);

void isom_eval_proj(MP *Q, const iso iso, const MP P);

/*
  Compute a 2-isogeny of the montgomery curve
  sending (x,z) to (1,...).
*/
void iso2_comp(iso2* iso, MC *phiE, const MC E, const KP P);

/* Apply a 2-isogeny of Montgomery curves */
void iso2_eval_kummer(KP *Q, const iso2 iso, const KP P);

void iso2_eval_proj(MP *Q, const iso2 iso, const MP P);

/*
  Compute a 3-isogeny of the montgomery curve
*/
void iso3_comp(iso3* iso, MC *phiE, const MC E, const KP P);

/* Apply a 3-isogeny of Montgomery curves */
void iso3_eval_kummer(KP *Q, const iso3 iso, const KP P);

void iso3_eval_proj(MP *Q, const iso3 iso, const MP P);

/*
  Compute a 4-isogeny of the Montgomery curve
  sending (1,...) to infinity.
*/
void iso4_comp(iso4* iso, MC *phiE, const MC E);

/* Apply a 4-isogeny of Montgomery curves */
void iso4_eval_kummer(KP *Q, const iso4 iso, const KP P);

void iso4_eval_proj(MP *Q, const iso4 iso, const MP P);
 
/******* COMPOSITE ISOGENIES **************/

/* Implementation of a queue */

typedef struct point_queue {
  //fp2 x,z;
  KP point;
  int h;
  struct point_queue *next, *prev;
};

void PQ_copy(point_queue *res, const point_queue pq);

void PQ_print(point_queue pq, char * str);

void PQ_init( point_queue *pq);

void PQ_clear(point_queue *pq);

#define Q_INIT(q) do {	     \
  q = malloc(sizeof(point_queue)); \
  if (q) {			     \
    q->next = q->prev = NULL;  \
    KP_init(&(q->point));  \
    q->h = 0; \
  }	   \
} while(0)
#define Q_CLEAR(q) do {   \
  KP_clear(&(q->point)); \
  free(q);		  \
} while(0)
#define Q_PUSH(tail,q) do {			\
  tail->next = q;				\
  q->prev = tail;				\
  tail = q;					\
} while(0)
#define Q_POP(tail,q) do {				\
  q = tail;						\
  tail = tail->prev;					\
  if (tail) {						\
    tail->next = NULL;				\
  }							\
} while(0)
#define Q_NEXT(q) (q->next)
#define Q_PREV(q) (q->prev)
#define Q_ISHEAD(q) (q->prev==NULL)
#define Q_ISTAIL(q) (q->next==NULL)

// These bits of code are almost identical for 1, 2, 3, 4
// isogenies, thus we "template" them.
#define APPLY_ISOG(apply_kummer, apply_proj,obj,lower) do {		\
  for ( tmp = tail ; tmp ; tmp = Q_PREV(tmp)) {	\
    apply_kummer(&(tmp->point.x), obj,		\
	  tmp->point);			\
    tmp->h = tmp->h - lower;				\
  }							\
  if (Pother){  \
    apply_proj(Pother, obj, *Pother);\
   }                           \
  if (Qother)					\
    apply_proj(Qother, obj, *Qother);		\
} while (0)              
#define COMP_ISOG(comp,obj) do {			\
  Q_POP(tail, tmp);					\
  comp(&obj, E, *E, tmp->point);	\
  Q_CLEAR(tmp);					\
} while (0)

union isogenies {
  struct {
    iso d1;
    iso2 d2;
    iso4 d4;
  };
  iso3 d3;
};

/* Push (Px, Py, Pz) and (Qx, Qy, Qz) through the isogeny of kernel
 generated by (Rx, Rz) using the given strategy. */
void push_through_iso_alice(MC *E,const MP R,const int ell, int *strategy, int h,MP *Pother,MP *Qother, int e);
	
void push_through_iso_bob(MC *E,const MP R,const int ell, int *strategy, int h,MP *Pother,MP *Qother, int e);

#endif